@startuml
autonumber

actor User as U
participant "main" as Main
participant "BiosInspectorApp" as App
participant "ChipsecExtractor" as Chipsec
participant "UefiExtractExtractor" as UEFIExt
participant "PeCoffAnalyzer" as PE
participant "ThreadPool" as Pool
participant "StringExtractor" as StrExt
participant "SensitiveMatcher" as Sens
participant "QilingExecutor" as QExec
participant "ManifestDAO" as MDAO
participant "ReportDAO" as RDAO

== Start ==
U -> Main : executa programa\n(ex: BIOSInspector.exe ...)
Main -> App : run(argc, argv)
activate App

App -> App : parseArgs(cfg)\nprepareWorkspace(cfg)

== Fase 1 CHIPSEC ==
App -> Chipsec : extract(cfg, modules)
activate Chipsec
Chipsec -> Chipsec : rodar chipsec_util.py\nextrair .efi
Chipsec --> App : modules preenchido
deactivate Chipsec

== Fase 2 UEFIExtract ==
App -> UEFIExt : extract(cfg, modules)
activate UEFIExt
UEFIExt -> UEFIExt : rodar UEFIExtract.exe\nrenomear body.bin,\ncopiar .efi para modulesDir
UEFIExt --> App : modules (atualizado)
deactivate UEFIExt

App -> App : cleanupInputArtifacts(cfg)

== Fase 3 PE COFF Analyzer ==
App -> PE : analyzeModules(cfg, modules, moduleRecords)
activate PE
PE -> PE : ler .efi\ncalcular SHA256, entropia\nassociar GUIDs
PE --> App : moduleRecords
deactivate PE

== buildModuleCatalog ==
App -> App : buildModuleCatalog(cfg, modulePaths, manifest)

App -> PE : analyzeModules(cfg, modulePaths, records)
activate PE
PE --> App : records
deactivate PE

App -> StrExt : criar instância
App -> Sens : criar instância, loadPatterns(cfg)
App -> QExec : criar instância
App -> Pool : criar ThreadPool(cfg.threads)
activate Pool

loop para cada ModuleRecord rec em records
  App -> Pool : enqueue(task para rec)
end

group execuções paralelas
  loop para cada tarefa
    Pool -> StrExt : extractStrings(cfg, rec)
    StrExt --> Pool

    Pool -> Sens : run(cfg, rec)
    Sens --> Pool

    alt cfg.enableQiling
      Pool -> QExec : executeModule(cfg, rec.path)
      QExec --> Pool : ExecutionStatus
    end
  end
end
deactivate Pool

App -> App : manifest.modules = records

== Persistência ==
App -> MDAO : save(cfg, manifest)
activate MDAO
MDAO --> App
deactivate MDAO

App -> RDAO : exportReports(cfg, manifest)
activate RDAO
RDAO --> App
deactivate RDAO

App --> Main : return 0
deactivate App

Main --> U : fim da execução\nmanifest.json e reports gerados

@enduml
